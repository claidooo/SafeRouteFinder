<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.min.js"></script>
    <style>
        #map { height: 100vh; }


        /* ‚úÖ Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            text-align: center;
            width: 80%;
            max-width: 300px;
            margin: 20% auto;
            border-radius: 10px;
        }
        .modal-buttons {
            margin-top: 10px;
            display: flex;
            justify-content: space-around;
        }
        .btn {
            padding: 8px 15px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
        .btn-confirm { background-color: green; color: white; }
        .btn-cancel { background-color: red; color: white; }


        .leaflet-control-zoom
        {
            position: absolute;
            bottom: 10px;  /* Adjust as necessary */
            right: 10px;   /* Adjust as necessary */
        }


        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out {
            background-color: #FFF; /* Change button color */
            border: 1px solid #7e71c3; /* Button border color */
            width: 40px;            /* Adjust size */
            height: 40px;           /* Adjust size */
        }
    </style>
</head>
<body>
<div id="map"></div>


<!-- ‚úÖ Custom Modal for Confirmation -->
<div id="confirmationModal" class="modal">
    <div class="modal-content">
        <p id="modalText">Start route to this destination?</p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="startRoute()">OK</button>
            <button class="btn btn-cancel" onclick="cancelRoute()">Cancel</button>
        </div>
    </div>
</div>


<script>
    let routeModeEnabled = false;
    var urlParams = new URLSearchParams(window.location.search);
    var userLat = parseFloat(urlParams.get('lat')) || 14.5833;
    var userLng = parseFloat(urlParams.get('lng')) || 120.9867;
    var destLat, destLng, streetName;
    var apiKey = "5b3ce3597851110001cf6248c374c1d74b7c461cb646776b494655f8"; // ORS API Key

    var map = L.map('map').setView([14.58594,120.98574], 16);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    map.zoomControl.setPosition('bottomright');

fetch('https://cs301projects.com/saferoutefinder/get_all_streets.php')
.then(response => response.json())

  .then(streets => {
    console.log(streets);
    // Initialize an array to store all markers
    let markers = [];

    streets.forEach(street => {
    console.log(`‚úÖ Placed ${markers.length} markers`);
      const lat = parseFloat(street.latitude);
      const lng = parseFloat(street.longitude);


      if (isNaN(lat) || isNaN(lng)) return;

      // Create a marker and add it to the map
      var marker = L.marker([lng, lat], {alt: street.name}).addTo(map); // Using street name as alt

      // Bind a popup with a simple string message
marker.bindPopup(`
  <div style="width: 200px; padding: 10px; background-color: #333; color: white; border-radius: 10px;">
      <h3 style="margin-top: 5px; font-size: 16px; margin-bottom: 5px; text-align: center;">${street.name}</h3>
      <div style="text-align: center;">
          <span style="color: #FFD700;">&#9733;</span>
          <span style="color: #FFD700;">&#9733;</span>
          <span style="color: #FFD700;">&#9733;</span>
          <span style="color: #FFD700;">&#9733;</span>
          <span style="color: #bbb;">&#9733;</span>
          <strong style="font-size: 16px;">${street.avg_user_rating || 'N/A'}</strong>
      </div>
      <p style="margin-top: 5px; font-size: 14px; color: #ccc; text-align: center;">${street.description || 'No description available'}</p>
  </div>
`);
      // Add the marker to the array
      markers.push(marker);
    });

  if (markers.length > 0) {
  const group = L.featureGroup(markers);
  map.fitBounds(group.getBounds().pad(0.2));
}


  })
  .catch(error => {
    console.error('‚ùå Error fetching street data:', error);
  });


    // ‚úÖ Mark User's Current Location
    var userMarker = L.marker([userLat, userLng], {icon: L.icon({
        iconUrl: 'https://cdn-icons-png.flaticon.com/512/447/447031.png',
        iconSize: [30, 30]
    })}).addTo(map).bindPopup("üìç You are here").openPopup();



    var destinationMarker, routeLayer;


    // ‚úÖ Handle Click to Set Destination
    map.on('click', function (e) {
    if (routeModeEnabled) {
        getStreetName(e.latlng.lat, e.latlng.lng);
    }
 });

 // üè´ Coordinates of Adamson University (approx)
const adamsonLat = 14.58594;
const adamsonLng = 120.98574;

// Add 500m circle to map
const radiusCircle = L.circle([adamsonLat, adamsonLng], {
    radius: 500,
    color: '#3388ff',
    fillColor: '#3388ff33',
    fillOpacity: 0.3
}).addTo(map);

// üå´ Create a gray mask outside the circle
const outerBounds = [
    [90, -180],  // top-left
    [90, 180],
    [-90, 180],
    [-90, -180],
];

function createCircleHole(center, radiusMeters, points = 60) {
    const coords = [];
    const earthRadius = 6371000; // meters

    for (let i = 0; i <= points; i++) {
        const angle = (i * 360) / points;
        const rad = angle * (Math.PI / 180);
        const dx = radiusMeters * Math.cos(rad);
        const dy = radiusMeters * Math.sin(rad);

        const latOffset = (dy / earthRadius) * (180 / Math.PI);
        const lngOffset = (dx / (earthRadius * Math.cos(center.lat * Math.PI / 180))) * (180 / Math.PI);

        coords.push([center.lat + latOffset, center.lng + lngOffset]);
    }
    return coords;
}

const center = { lat: adamsonLat, lng: adamsonLng };
const hole = createCircleHole(center, 500);

const mask = L.polygon([
    outerBounds,
    hole
], {
    color: '#999',
    fillColor: '#999',
    fillOpacity: 0.5,
    stroke: false
}).addTo(map);




    // ‚úÖ Get Street Name from Reverse Geocoding
    function getStreetName(lat, lng) {
        fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`)
            .then(response => response.json())
            .then(data => {
                if (data && data.address) {
                    streetName = data.address.road || "Unknown Street";
                } else {
                    streetName = "Unknown Location";
                }


                showConfirmationModal(lat, lng, streetName);
            })
            .catch(error => {
                console.error("‚ùå Error getting street name:", error);
                streetName = "Unknown Location";
                showConfirmationModal(lat, lng, streetName);
            });
    }


    // ‚úÖ Show Custom Modal
    function showConfirmationModal(lat, lng, street) {
        destLat = lat;
        destLng = lng;


        // Remove old destination marker
        if (destinationMarker) {
            map.removeLayer(destinationMarker);
        }


        // Add new destination marker
        destinationMarker = L.marker([lat, lng]).addTo(map)
            .bindPopup(`üìç Destination: ${street}`).openPopup();


        document.getElementById("modalText").innerHTML = `Start route to <b>${street}</b>?`;
        document.getElementById("confirmationModal").style.display = "block";
    }

    // ‚úÖ Start Route if User Confirms
    function startRoute() {
        document.getElementById("confirmationModal").style.display = "none";
        routeModeEnabled = false;
        findRoute(userLat, userLng, destLat, destLng);
    }


   // ‚úÖ Cancel Route and Remove Marker
   function cancelRoute() {
       document.getElementById("confirmationModal").style.display = "none";


       if (destinationMarker) {
           map.removeLayer(destinationMarker);
           destinationMarker = null;
       }
   }

function findRoute(startLat, startLng, endLat, endLng) {
    if (routeLayer) {
        map.removeLayer(routeLayer);
    }

    // Create routing control
    routeLayer = L.Routing.control({
        waypoints: [
            L.latLng(startLat, startLng),
            L.latLng(endLat, endLng)
        ],
        lineOptions: {
            styles: [{ color: 'blue', opacity: 0.7, weight: 5 }]
        },
        router: L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: 'foot'
        }),
        addWaypoints: false,
        draggableWaypoints: false,
        createMarker: () => null // don't create extra default markers
    })
    .on('routesfound', function (e) {
                    const route = e.routes[0];
                    const distance = (route.summary.totalDistance / 1000).toFixed(2);
                    const timeInMinutes = Math.ceil(route.summary.totalTime / 60);

                    const now = new Date();
                    const arrivalTime = new Date(now.getTime() + timeInMinutes * 60000).toLocaleTimeString();

                    console.log(`Distance: ${distance} km, Time: ${timeInMinutes} minutes, Arrival: ${arrivalTime}`);

                    if (typeof Android !== "undefined" && Android.showRouteDetails) {
                        Android.showRouteDetails(distance, timeInMinutes, arrivalTime);
                    }
                })
    .on('routingerror', function (e) {
        console.error("Routing error:", e);
        alert("An error occurred while trying to find a route.");
    })
    .addTo(map);

    // Hide default Leaflet Routing panel (optional)
    setTimeout(() => {
        const panel = document.querySelector('.leaflet-routing-container');
        if (panel) panel.style.display = 'none';
    }, 100);
}

   function enableRouteMode() {
       routeModeEnabled = true;
   }
</script>
</body>
</html>


